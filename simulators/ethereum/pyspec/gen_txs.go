// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package main

import (
	"encoding/json"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/core/types"
)

var _ = (*transactionUnmarshaling)(nil)

// MarshalJSON marshals as JSON.
func (t transaction) MarshalJSON() ([]byte, error) {
	type transaction struct {
		Type                 *math.HexOrDecimal64  `json:"type"`
		ChainId              *math.HexOrDecimal256 `json:"chainId"`
		Nonce                math.HexOrDecimal64   `json:"nonce"`
		MaxPriorityFeePerGas *math.HexOrDecimal256 `json:"maxPriorityFeePerGas"`
		MaxFeePerGas         *math.HexOrDecimal256 `json:"maxFeePerGas"`
		To                   string                `json:"to"`
		Gas                  math.HexOrDecimal64   `json:"gasLimit"`
		Value                *math.HexOrDecimal256 `json:"value"`
		Input                hexutil.Bytes         `json:"data"`
		AccessList           *types.AccessList     `json:"accessList"`
		MaxFeePerBlobGas     *math.HexOrDecimal256 `json:"maxFeePerBlobGas"`
		BlobVersionedHashes  []*common.Hash        `json:"blobVersionedHashes"`
		V                    *math.HexOrDecimal256 `json:"v"`
		R                    *math.HexOrDecimal256 `json:"r"`
		S                    *math.HexOrDecimal256 `json:"s"`
		Sender               common.Address        `json:"sender"`
	}
	var enc transaction
	enc.Type = (*math.HexOrDecimal64)(t.Type)
	enc.ChainId = (*math.HexOrDecimal256)(t.ChainId)
	enc.Nonce = math.HexOrDecimal64(t.Nonce)
	enc.MaxPriorityFeePerGas = (*math.HexOrDecimal256)(t.MaxPriorityFeePerGas)
	enc.MaxFeePerGas = (*math.HexOrDecimal256)(t.MaxFeePerGas)
	enc.To = t.To
	enc.Gas = math.HexOrDecimal64(t.Gas)
	enc.Value = (*math.HexOrDecimal256)(t.Value)
	enc.Input = t.Input
	enc.AccessList = t.AccessList
	enc.MaxFeePerBlobGas = (*math.HexOrDecimal256)(t.MaxFeePerBlobGas)
	enc.BlobVersionedHashes = t.BlobVersionedHashes
	enc.V = (*math.HexOrDecimal256)(t.V)
	enc.R = (*math.HexOrDecimal256)(t.R)
	enc.S = (*math.HexOrDecimal256)(t.S)
	enc.Sender = t.Sender
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (t *transaction) UnmarshalJSON(input []byte) error {
	type transaction struct {
		Type                 *math.HexOrDecimal64  `json:"type"`
		ChainId              *math.HexOrDecimal256 `json:"chainId"`
		Nonce                *math.HexOrDecimal64  `json:"nonce"`
		MaxPriorityFeePerGas *math.HexOrDecimal256 `json:"maxPriorityFeePerGas"`
		MaxFeePerGas         *math.HexOrDecimal256 `json:"maxFeePerGas"`
		To                   *string               `json:"to"`
		Gas                  *math.HexOrDecimal64  `json:"gasLimit"`
		Value                *math.HexOrDecimal256 `json:"value"`
		Input                *hexutil.Bytes        `json:"data"`
		AccessList           *types.AccessList     `json:"accessList"`
		MaxFeePerBlobGas     *math.HexOrDecimal256 `json:"maxFeePerBlobGas"`
		BlobVersionedHashes  []*common.Hash        `json:"blobVersionedHashes"`
		V                    *math.HexOrDecimal256 `json:"v"`
		R                    *math.HexOrDecimal256 `json:"r"`
		S                    *math.HexOrDecimal256 `json:"s"`
		Sender               *common.Address       `json:"sender"`
	}
	var dec transaction
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Type != nil {
		t.Type = (*uint64)(dec.Type)
	}
	if dec.ChainId != nil {
		t.ChainId = (*big.Int)(dec.ChainId)
	}
	if dec.Nonce != nil {
		t.Nonce = uint64(*dec.Nonce)
	}
	if dec.MaxPriorityFeePerGas != nil {
		t.MaxPriorityFeePerGas = (*big.Int)(dec.MaxPriorityFeePerGas)
	}
	if dec.MaxFeePerGas != nil {
		t.MaxFeePerGas = (*big.Int)(dec.MaxFeePerGas)
	}
	if dec.To != nil {
		t.To = *dec.To
	}
	if dec.Gas != nil {
		t.Gas = uint64(*dec.Gas)
	}
	if dec.Value != nil {
		t.Value = (*big.Int)(dec.Value)
	}
	if dec.Input != nil {
		t.Input = *dec.Input
	}
	if dec.AccessList != nil {
		t.AccessList = dec.AccessList
	}
	if dec.MaxFeePerBlobGas != nil {
		t.MaxFeePerBlobGas = (*big.Int)(dec.MaxFeePerBlobGas)
	}
	if dec.BlobVersionedHashes != nil {
		t.BlobVersionedHashes = dec.BlobVersionedHashes
	}
	if dec.V != nil {
		t.V = (*big.Int)(dec.V)
	}
	if dec.R != nil {
		t.R = (*big.Int)(dec.R)
	}
	if dec.S != nil {
		t.S = (*big.Int)(dec.S)
	}
	if dec.Sender != nil {
		t.Sender = *dec.Sender
	}
	return nil
}
